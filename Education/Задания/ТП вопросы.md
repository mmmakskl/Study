1. **Что возвращает оператор `sizeof`?**
   - Оператор `sizeof` возвращает размер, в байтах, переменной или типа данных. Этот размер включает любые дополнительные байты, которые компилятор добавляет для выравнивания.

2. **По каким правилам преобразуются к типу `bool` значения числовых типов, символы и указатели?**
   - Числовые значения (включая символы) преобразуются в `true`, если они ненулевые, и в `false`, если они равны нулю. Указатели преобразуются в `true`, если они не нулевые, и в `false`, если они равны `nullptr`.

3. **Почему преобразование значений типа `int` к типу `float`, начиная с определённого числа, происходит с погрешностью?**
   - Преобразование типа `int` в `float` может приводить к потере точности, так как `float` имеет ограниченное количество значащих цифр (обычно 7), что может быть недостаточно для точного представления больших целых чисел.

4. **В чём разница между операторами `&` и `&&`, а также `|` и `||`?**
   - `&` — это побитовый оператор И, который выполняет операцию побитового И над соответствующими битами двух операндов. `&&` — это логический оператор И, который выполняет логическую операцию И над двумя выражениями и возвращает `true`, если оба выражения истинны. Аналогично, `|` — это побитовый оператор ИЛИ, а `||` — логический оператор ИЛИ, который возвращает `true`, если хотя бы одно из выражений истинно.

5. **Что будет, если локальную переменную функции определить с ключевым словом `static`?**
   - Локальная переменная, объявленная с ключевым словом `static`, сохраняет своё значение между вызовами функции. Она инициализируется только один раз, при первом вызове функции, и сохраняет своё значение до завершения программы.

6. **Почему время доступа к элементу массива по индексу O(const)?**
   - Время доступа к элементу массива по индексу является O(1) (константное время), потому что массивы предоставляют прямой доступ к любому элементу через индекс, что требует лишь одного арифметического вычисления для нахождения нужного элемента.

7. **Что такое header guard?**
   - Header guard — это конструкция, используемая в заголовочных файлах для предотвращения их многократного включения. Обычно она состоит из трёх директив препроцессора: `#ifndef`, `#define` и `#endif`, которые обеспечивают, что содержимое файла включается только один раз.

8. **Как компилятор определяет, когда использовать конструктор копирования, а когда конструктор перемещения?**
   - Компилятор выбирает конструктор копирования, если передаётся lvalue (выражение, которое имеет адрес), и конструктор перемещения, если передаётся rvalue (выражение, не имеющее адреса и временное). Если объект может быть перемещён (т.е. не требуется оставлять копию), используется конструктор перемещения.

9. **Для чего нужны виртуальные функции?**
   - Виртуальные функции позволяют производным классам переопределять методы базового класса. Они обеспечивают динамическое связывание, что позволяет вызывать переопределённые методы производных классов через указатели или ссылки на базовые классы.

10. **Почему наследование от класса с НЕвиртуальным деструктором может быть небезопасным?**
    - Если базовый класс имеет не виртуальный деструктор, при удалении объекта производного класса через указатель на базовый класс вызовется только деструктор базового класса, что может привести к утечке ресурсов или некорректному завершению работы программы.

11. **Как работает преобразование `dynamic_cast`?**
    - `dynamic_cast` используется для безопасного преобразования указателей и ссылок на базовые классы в указатели и ссылки на производные классы. Если преобразование невозможно, он возвращает `nullptr` для указателей или бросает исключение `std::bad_cast` для ссылок.

12. **Какие бывают гарантии безопасности исключений?**
    - Существует три основные гарантии безопасности исключений:
      - **Основная гарантия**: если исключение будет выброшено, программа останется в корректном состоянии.
      - **Строгая гарантия**: если исключение будет выброшено, программа останется в состоянии, которое существовало до выполнения операции.
      - **Гарантия отсутствия исключений**: операция гарантированно не выбросит исключение.

13. **В чём отличие функции `malloc` от оператора `new`?**
    - `malloc` выделяет память, но не вызывает конструкторы объектов, и возвращает указатель типа `void*`, который нужно приводить к нужному типу. `new` выделяет память и вызывает конструкторы объектов, возвращая указатель нужного типа. Также `new` бросает исключение `std::bad_alloc` при неудачной попытке выделения памяти, в то время как `malloc` возвращает `nullptr`.

14. **Что такое умный указатель? Какие умные указатели есть в стандартной библиотеке?**
    - Умный указатель — это объект, который управляет временем жизни других объектов через указатели. В стандартной библиотеке C++ есть три основных умных указателя:
      - `std::unique_ptr` — уникальный указатель, который владеет объектом и не позволяет копировать владение.
      - `std::shared_ptr` — разделяемый указатель, который позволяет нескольким указателям совместно владеть объектом.
      - `std::weak_ptr` — слабый указатель, который ссылается на объект, управляемый `std::shared_ptr`, но не увеличивает счётчик ссылок, предотвращая циклические зависимости.

15. **Когда следует использовать перегрузку, а когда шаблон функции?**
    - Перегрузку функций следует использовать, когда требуется определить несколько функций с одним именем, но различными наборами параметров. Шаблоны функций следует использовать, когда функция должна работать с различными типами данных, но логика выполнения остаётся неизменной.

16. **Что такое специализация шаблона?**
    - Специализация шаблона позволяет определить особую реализацию шаблона для конкретного типа данных. В C++ есть полная специализация (для конкретного типа) и частичная специализация (для некоторых типов параметров шаблона).

17. **Какие категории итераторов используются в стандартной библиотеке?**
    - В стандартной библиотеке C++ используются следующие категории итераторов:
      - Входные итераторы (Input Iterators)
      - Выходные итераторы (Output Iterators)
      - Однонаправленные итераторы (Forward Iterators)
      - Двусторонние итераторы (Bidirectional Iterators)
      - Итераторы произвольного доступа (Random Access Iterators)

18. **В чём разница между методами `size` и `capacity` класса `std::vector`?**
    - `size` возвращает количество элементов в векторе, а `capacity` возвращает количество элементов, которое вектор может хранить без необходимости выделения дополнительной памяти.

19. **Какие последовательные контейнеры есть в стандартной библиотеке?**
    - В стандартной библиотеке C++ есть следующие последовательные контейнеры:
      - `std::vector`
      - `std::deque`
      - `std::list`
      - `std::array`
      - `std::forward_list`

20. **Какие ассоциативные контейнеры есть в стандартной библиотеке?**
    - В стандартной библиотеке C++ есть следующие ассоциативные контейнеры:
      - `std::set`
      - `std::multiset`
      - `std::map`
      - `std::multimap`
      - `std::unordered_set`
      - `std::unordered_multiset`
      - `std::unordered_map`
      - `std::unordered_multimap`
